//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Geometries;
using System.Linq;
using System.Windows.Forms;
using System.Workspace;
using System.Workspace.Drawing;

namespace System.Windows.Modules
{
    internal partial class FeatureSelectionComponent : ApplicationComponent<IProject>, ISupportGeometryProperty, IPropertySetter
    {
        public FeatureSelectionComponent(IProject project, Action<IProject> updateCommands)
            : base(project.Designer, project)
        {
            Project = project;
            Project.Workspace.BeginRender += OnRenderBegin;
            Project.Workspace.FeatureRender += OnRenderFeature;
            Project.Workspace.RenderCompleted += OnRenderCompleted;
            (UpdateCommandsAction = updateCommands)(Project);

            PreviewBounds = project.Factory.Create<IEnvelope>();

            PropertyTolerance = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.Tolerance);
            PropertyLayer = new PropertyDescriptor<FeatureSelectionComponent>("Layer", Categories.General, typeof(MapLayer));

            PropertyOffset = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.Offset);
            PropertyOffsetX = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.OffsetX);
            PropertyOffsetY = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.OffsetY);

            PropertyScaleOffset = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.ScaleOffset);
            PropertyScale = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.Scale);
            PropertyScaleX = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.ScaleX);
            PropertyScaleY = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.ScaleY);

            PropertyRotationOffset = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.RotationOffset);
            PropertyRotation = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.Rotation);

            PropertyBuffer = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.Buffer);
            PropertyBufferWidth = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.BufferWidth);
            PropertyBufferHeight = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.BufferHeight);
            PropertyBufferLineJoin = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.BufferLineJoin);
            PropertyBufferCapStyle = GeometryFactory.CreatePropertyDescriptor(this, GeometryProperty.BufferEndCapStyle);

            Properties[GeometryProperty.BufferLineJoin] = JoinStyle.Round;
            Properties[GeometryProperty.BufferEndCapStyle] = EndCapStyle.Round;
        }

        protected IProject Project;
        protected Action<IProject> UpdateCommandsAction;

        protected PropertyDescriptor PropertyTolerance;
        protected PropertyDescriptor PropertyLayer;
        protected PropertyDescriptor PropertyAltitude;

        protected PropertyDescriptor PropertyOffset;
        protected PropertyDescriptor PropertyOffsetX;
        protected PropertyDescriptor PropertyOffsetY;

        protected PropertyDescriptor PropertyScaleOffset;
        protected PropertyDescriptor PropertyScale;
        protected PropertyDescriptor PropertyScaleX;
        protected PropertyDescriptor PropertyScaleY;

        protected PropertyDescriptor PropertyRotationOffset;
        protected PropertyDescriptor PropertyRotation;

        protected PropertyDescriptor PropertyBuffer;
        protected PropertyDescriptor PropertyBufferWidth;
        protected PropertyDescriptor PropertyBufferHeight;
        protected PropertyDescriptor PropertyBufferLineJoin;
        protected PropertyDescriptor PropertyBufferCapStyle;

        protected bool Copied;
        protected ICoordinate DragAt;
        protected internal ICoordinate ScaleAt;
        protected internal ICoordinate RotateAt;
        protected Image PreviewImage;
        protected MapCanvas PreviewCanvas;
        protected IEnvelope PreviewBounds;
        protected IApplicationComponent DragComponent;

        public override bool IsEmpty()
        {
            return Project.IsNull() || Project.Workspace.SelectionIsEmpty;
        }

        public bool IsSelectedAll()
        {
            return Project.Workspace.SelectedAll;
        }

        public override void AddProperties(PropertyDescriptorCollection properties)
        {
            properties.Add(PropertyTolerance);

            if (IsEmpty() == false)
            {
                properties.Add(PropertyLayer);
                properties.Add(PropertyAltitude);
                properties.Add(PropertyOffset);
            }

            properties.Add(PropertyOffsetX);
            properties.Add(PropertyOffsetY);

            properties.Add(PropertyScaleOffset);
            properties.Add(PropertyScale);
            properties.Add(PropertyScaleX);
            properties.Add(PropertyScaleY);

            properties.Add(PropertyRotationOffset);
            properties.Add(PropertyRotation);

            properties.Add(PropertyBuffer);
            properties.Add(PropertyBufferWidth);
            properties.Add(PropertyBufferHeight);
            properties.Add(PropertyBufferLineJoin);
            properties.Add(PropertyBufferCapStyle);

            base.AddProperties(properties);
        }

        public void Clear()
        {
            Project.Workspace.GetLayers().ForEach(item => item.Selection.Clear());
        }

        public void SelectAll()
        {
            GetLayers().ForEach(item => item.Selection.SelectAll());
            OnChanged();
        }

        public void DeselectAll()
        {
            Clear();
            OnChanged();
        }

        public void ReverseSelection()
        {
            GetLayers().ForEach(item => item.Selection.ReverseSelection());
            OnChanged();
        }

        public void Copy()
        {
            Designer.Redraw();
        }

        public void SelectByRect()
        {
            IApplicationComponent rect = Project.Factory.Create<IRectangle>().GetComponent(Project.Designer);

            rect.AllowProperties = false;

            rect.Paint += (e) =>
            {
                e.Pen = ApplicationAppereance.Pens.SnapHotTrack;
            };

            rect.EditCompleted += (e) =>
            {
                if (e.Action == ComponentEditCompleteAction.Complete)
                {
                    AddRect(e.Component.Value as IRectangle);
                }
            };

            Project.Designer.BeginEdit(rect);
        }

        public void SelectByPolygon()
        {
            IApplicationComponent poly = Project.Factory.Create<IPolygon>().GetComponent(Project.Designer);

            poly.AllowProperties = false;

            poly.Paint += (e) =>
            {
                e.Pen = ApplicationAppereance.Pens.SnapHotTrack;
            };

            poly.EditCompleted += (e) =>
            {
                if (e.Action == ComponentEditCompleteAction.Complete)
                {
                    AddPolygon(e.Component.Value as IPolygon);
                }
            };

            Project.Designer.BeginEdit(poly);
        }

        public void AddRect(IRectangle rect)
        {
            if (rect.IsEmpty() == false)
            {
                IEnvelope e = rect.GetBounds();

                if (e.IsEmpty() == false)
                {
                    IGeometry polygon = e.ToPolygon();

                    foreach (MapLayer layer in GetLayers())
                    {
                        foreach (IFeatureRecord r in layer.GetFeatures(e))
                        {
                            if (polygon.IsContains(r.GetGeometry()))
                            {
                                AddRemoveFeature(layer, r, false);
                            }
                        }
                    }

                    OnChanged();
                }
            }
        }

        public void AddPolygon(IPolygon poly)
        {
            if (poly.IsEmpty() == false)
            {
                IEnvelope e = poly.GetBounds();

                if (e.IsEmpty() == false)
                {
                    foreach (MapLayer layer in GetLayers())
                    {
                        foreach (IFeatureRecord r in layer.GetFeatures(e))
                        {
                            if (poly.IsContains(r.GetGeometry()))
                            {
                                AddRemoveFeature(layer, r, false);
                            }
                        }
                    }

                    OnChanged();
                }
            }
        }

        public void Add(FeatureItem item)
        {
            AddRemoveFeature(item.Layer, item.Feature);
        }

        public void AddRemoveFeature(MapLayer layer, IFeatureRecord record)
        {
            AddRemoveFeature(layer, record, true);
        }

        protected void AddRemoveFeature(MapLayer layer, IFeatureRecord record, bool raiseChanged)
        {
            object featureId = record.GetFeatureId();

            if (layer.Selection.Add(featureId) == false)
            {
                layer.Selection.Remove(featureId);
            }

            if (raiseChanged)
            {
                OnChanged();
            }
        }

        public void Overlay(SpatialFunctions function)
        {
            using (var e = new SelectionOverlayEventArgs(this, function))
            {
                OnComplete(e);
            }
        }

        public void Split()
        {
            using (var e = new SelectionSplitEventArgs(this))
            {
                OnComplete(e);
            }
        }

        public void LinesToPolygon()
        {
            using (var e = new SelectionToPolygonEventArgs(this))
            {
                OnComplete(e);
            }
        }

        public void Delete()
        {
            OnDelete();
        }

        public void Cancel()
        {
            OnEndEdit(ComponentEditCompleteAction.Cancel);
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);

            if (PreviewImage.HasValue())
            {
                float offsetX = 0;
                float offsetY = 0;

                if (DragAt.HasValue())
                {
                    PointF p1 = Designer.Transform.WorldToClient(DragAt);
                    PointF p2 = Designer.Transform.WorldToClient(DragComponent.Value as ICoordinate);

                    offsetX = p2.X - p1.X;
                    offsetY = p2.Y - p1.Y;
                }
                else
                {
                    var x = (float?)Properties[GeometryProperty.OffsetX];
                    var y = (float?)Properties[GeometryProperty.OffsetY];

                    offsetX = (float)((x.HasValue ? x.Value : offsetX) / Designer.Transform.PixelSize);
                    offsetY = -(float)((y.HasValue ? y.Value : offsetY) / Designer.Transform.PixelSize);
                }

                var rotation = (float?)Properties[GeometryProperty.Rotation];
                var scaleX = (float?)Properties[GeometryProperty.ScaleX];
                var scaleY = (float?)Properties[GeometryProperty.ScaleY];

                using (var transform = new Matrix())
                {
                    var center = RotateAt ?? ScaleAt;
                    var rect = Designer.Transform.WorldToClient(PreviewBounds);

                    transform.Translate(offsetX, offsetY);

                    if ((RotateAt ?? center).HasValue() && rotation.HasValue)
                    {
                        transform.RotateAt(rotation.Value, Designer.Transform.WorldToClient(RotateAt ?? center));
                    }

                    if ((ScaleAt ?? center).HasValue() && (scaleX.HasValue || scaleY.HasValue))
                    {
                        transform.ScaleAt(scaleX.HasValue ? scaleX.Value / 100F : 1F, scaleY.HasValue ? scaleY.Value / 100F : 1F, Designer.Transform.WorldToClient(ScaleAt ?? center));
                    }

                    e.Graphics.Transform = transform;
                    e.Graphics.DrawImage(PreviewImage, rect);
                    e.Graphics.ResetTransform();
                }
            }
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                OnEndEdit(ComponentEditCompleteAction.Complete);
            }
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            Designer.Flush();
        }

        protected void OnDragPointEditCompleted(ApplicationComponentEditCompletedEventArgs e)
        {
            bool copy = Project.Application.CopyMode;

            if (e.Action == ComponentEditCompleteAction.Complete)
            {
                Copied = true;
                OnEditCompleted(ComponentEditCompleteAction.Complete);

                if (IsDisposed)
                {
                    return;
                }

                if (copy)
                {
                    StartDrag(e.Component.Value as ICoordinate);
                }
                else
                {
                    DragAt = null;
                    DragComponent = null;
                }
            }
            else
            {
                DragAt = null;
                DragComponent = null;

                if (Copied)
                {
                    OnEndEdit(ComponentEditCompleteAction.Cancel);
                }
            }
        }

        public void StartDrag(ICoordinate point)
        {
            DragAt = point.Clone();
            DragComponent = point.GetComponent(Designer);
            DragComponent.Parent = this;
            DragComponent.EditCompleted += OnDragPointEditCompleted;

            Designer.BeginEdit(DragComponent);
            Designer.Redraw();
        }

        protected bool GetDragOffset(out double x, out double y)
        {
            if (DragComponent.HasValue() && DragAt.HasValue())
            {
                var c = DragComponent.Value as ICoordinate;

                if (c.HasValue())
                {
                    x = c.X - DragAt.X;
                    y = c.Y - DragAt.Y;

                    return true;
                }
            }
            else
            {
                var offsetX = (float?)Properties[GeometryProperty.OffsetX];
                var offsetY = (float?)Properties[GeometryProperty.OffsetY];

                x = offsetX.HasValue ? offsetX.Value : 0.0;
                y = offsetY.HasValue ? offsetY.Value : 0.0;

                return offsetX.HasValue || offsetY.HasValue;
            }

            x = 0.0;
            y = 0.0;
            return false;
        }

        public void Complete(ComponentEditCompleteAction action)
        {
            OnEditCompleted(action);
        }

        protected override void OnEditCompleted(ComponentEditCompleteAction action)
        {
            if (action != ComponentEditCompleteAction.Cancel && PreviewBounds.HasValue() && PreviewBounds.IsEmpty() == false)
            {
                using (var e = new SelectionDoWorkEventArgs(this, action))
                {
                    if (OnComplete(e) == false)
                    {
                        base.OnEditCompleted(ComponentEditCompleteAction.Cancel);
                    }
                }
            }
            else
            {
                Project.Render();
                base.OnEditCompleted(action);
            }
        }

        protected virtual bool OnComplete(SelectionDoWorkEventArgs e)
        {
            if (e.IsEmpty == false && e.MoveNext())
            {
                using (Project.TransactionLog.Begin(e.AlwaysTransactional || e.MoveNext()))
                {
                    do
                    {
                        if (e.DoWork())
                        {
                            continue;
                        }

                        break;
                    }
                    while (e.MoveNext());
                }
            }

            if (e.Continue)
            {
                Project.Render();
            }
            else
            {
                base.OnEditCompleted(e.Action);
            }

            return true;
        }

        protected void OnChanged()
        {
            if (IsEmpty())
            {
                Project.Application.Form.DockManager.ProjectPanel.Activate();
            }
            else
            {
                Project.Application.Form.DockManager.PropertiesPanel.Control.SelectedObject = this;
                Project.Application.Form.DockManager.PropertiesPanel.Control.Refresh(true);
                Project.Application.Form.DockManager.PropertiesPanel.Activate();
            }

            UpdateCommandsAction(Project);
            Designer.Redraw();
        }

        protected void OnRenderBegin(MapWorkspace workspace)
        {
            PreviewImage.DisposeSafely();
            PreviewImage = null;

            if (PreviewBounds.HasValue())
            {
                PreviewBounds.SetNull();
                PreviewCanvas.DisposeSafely();
                PreviewCanvas = workspace.Canvas.Clone();
            }
        }

        protected void OnRenderFeature(FeatureDrawEventArgs e)
        {
            if (e.IsSelected)
            {
                IGeometry g = e.Geometry;

                if (g.HasValue())
                {
                    PreviewBounds.ExpandToInclude(g.GetBounds());

                    if (PreviewCanvas.HasValue())
                    {
                        PreviewCanvas.Graphics.Draw(g, e.Style, Designer.Transform.WorldToClient, true);
                    }

                    e.Cancel = false;
                }
            }
        }

        protected void OnRenderCompleted(RenderCompletedEventArgs e)
        {
            if (PreviewBounds.HasValue() && PreviewBounds.IsEmpty() == false)
            {
                using (PreviewCanvas)
                {
                    double pixel = e.Canvas.Graphics.Transform.PixelSize * 10.0;

                    PreviewBounds.Inflate(pixel, pixel);

                    if (PreviewCanvas.HasValue())
                    {
                        PreviewImage.DisposeSafely();
                        PreviewImage = PreviewCanvas.Graphics.Clip(ref PreviewBounds);
                        PreviewImage = PreviewImage.HasValue() ? PreviewImage.GetThumbnailImage(PreviewImage.Width, PreviewImage.Height, null, IntPtr.Zero) : null;
                        Designer.Flush();
                    }
                }

                PreviewCanvas = null;
            }
        }

        public object GetValue(GeometryProperty property)
        {
            double offsetX, offsetY;

            switch (property)
            {
                case GeometryProperty.Offset:
                    return default(ICoordinate);

                case GeometryProperty.OffsetX:
                    return GetDragOffset(out offsetX, out offsetY) ? offsetX : 0.0;

                case GeometryProperty.OffsetY:
                    return GetDragOffset(out offsetX, out offsetY) ? offsetY : 0.0;

                case GeometryProperty.ScaleOffset:
                    return ScaleAt;

                case GeometryProperty.Scale:
                case GeometryProperty.ScaleX:
                case GeometryProperty.ScaleY:
                    return Properties[property] ?? 100.0;

                case GeometryProperty.RotationOffset:
                    return RotateAt;

                case GeometryProperty.Tolerance:
                    return Properties[GeometryProperty.Tolerance] ?? Designer.Transform.PixelSize;
            }

            return Properties[property] ?? 0.0;
        }

        public void SetValue(GeometryProperty property, object value)
        {
            if (DragComponent.HasValue())
            {
                if (property == GeometryProperty.OffsetX)
                {
                    DragComponent.Properties[GeometryProperty.X] = DragAt.X + (double)value;
                    DragComponent.Validate();
                }
                else if (property == GeometryProperty.OffsetY)
                {
                    DragComponent.Properties[GeometryProperty.Y] = DragAt.Y + (double)value;
                    DragComponent.Validate();
                }
            }

            switch (property)
            {
                case GeometryProperty.Scale:
                    SetValue(GeometryProperty.ScaleX, value);
                    SetValue(GeometryProperty.ScaleY, value);
                    break;
                case GeometryProperty.Buffer:
                    SetValue(GeometryProperty.BufferWidth, value);
                    SetValue(GeometryProperty.BufferHeight, value);
                    break;
                case GeometryProperty.ScaleX:
                case GeometryProperty.ScaleY:
                    if ((float)value <= 0F) value = 100F;
                    break;
            }

            if (value is double)
            {
                Properties[property] = (float)(double)value;
            }
            else
            {
                Properties[property] = value;
            }
        }

        protected IEnumerable<MapLayer> GetLayers()
        {
            return Project.Workspace.GetLayers().Where(item => item.Visibility);
        }

        public object this[int index]
        {
            get { throw new NotImplementedException(); }
            set { throw new NotImplementedException(); }
        }

        public object this[string name]
        {
            get { return default; }
            set
            {
                switch (name)
                {
                    case "Layer":
                        OnChangeLayer(value as MapLayer);
                        break;
                }
            }
        }

        protected virtual void OnChangeLayer(MapLayer destination)
        {
            if (destination.HasValue())
            {
                using (Project.TransactionLog.Begin())
                {
                    bool copy = Project.Application.CopyMode;
                    IEnumerator<MapFeature> e = Project.Workspace.GetSelectedFeatures().GetEnumerator();

                    while (e.MoveNext())
                    {
                        IFeature feature = destination.ImportFeature(e.Current.Feature);

                        feature.SetFeatureId(default);
                        feature.EndEdit();

                        if (copy)
                        {
                            continue;
                        }

                        e.Current.Layer.ExecuteDelete(e.Current.Feature);
                    }
                }

                Cancel();
            }
        }

        protected override void OnDispose()
        {
            base.OnDispose();

            if (Project.HasValue())
            {
                Project.Workspace.BeginRender -= OnRenderBegin;
                Project.Workspace.FeatureRender -= OnRenderFeature;

                PreviewImage.DisposeSafely();
                PreviewCanvas.DisposeSafely();

                PreviewImage = null;
                PreviewCanvas = null;
                PreviewBounds = null;
                DragAt = null;
                DragComponent = null;
                UpdateCommandsAction = null;
                Project = null;
            }
        }
    }
}