//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Configuration;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Geometries;
using System.Geometries.Index;
using System.Linq;
using System.Windows.Forms;
using System.Workspace;

namespace System.Windows.Modules
{
    internal class SnapObjectCollection : ISnapObjectCollection, IApplicationComponentValidator
    {
        public SnapObjectCollection(IProject project)
        {
            Project = project;
            Project.ActiveComponentChanged += OnActiveComponentChanged;
            Project.Designer.MouseMove += OnDesignerMouseMove;
            Project.Workspace.BeginRender += OnBeginRender;
            Project.Workspace.RenderCompleted += OnRenderCompleted;

            Project.Application.Settings.Snap.PropertyChanged += OnSnapSettingsChanged;
            Project.Application.Settings.AlignmentGuides.PropertyChanged += OnAlignmentGuidesSettingsChanged;

            ActiveObjects = new List<SnapObject>();
            AlignmentGuides = new List<ICoordinate>();

            Location = Project.Factory.Create<ICoordinate>(0.0, 0.0);
            CurrentSegment = Project.Factory.Create<ILineSegment>(0.0, 0.0, 0.0, 0.0);
        }

        protected readonly IProject Project;

        protected const float SnapDistance = 8;
        protected const int SnapQueryBoundsRadius = 36;

        protected const float PointRadius = 4;
        protected const float MidPointRadius = 4;
        protected const float CenterPointRadius = 4;
        protected const float CenterPointDiameter = 8;

        protected ISpatialIndex<SnapObject> SnapIndex;
        protected ICoordinate Location;
        protected SnapObject Current;
        protected ICoordinate SnapLocation;
        protected ICoordinate GuideOrigin;
        protected ILineSegment CurrentSegment;
        protected ILineSegment ClosestSegment;
        protected IApplicationComponent Component;
        protected List<SnapObject> ActiveObjects;
        protected List<ICoordinate> AlignmentGuides;

        public bool Enabled
        {
            get { return Project.Application.Settings.Snap.Enabled && Project.Designer.ActiveComponent.HasValue() && Project.Designer.ActiveComponent.Value is ICoordinate; }
        }

        public int Priority
        {
            get { return 100; }
        }

        public void Insert(PointVisitedEventArgs e)
        {
            SnapIndex.Insert(e.Value.GetBounds(), new SnapObject(e));
        }

        protected void OnBeginRender(MapWorkspace workSpace)
        {
            Project.Factory.PointVisited -= Insert;
            SnapIndex = null;

            if (Enabled)
            {
                SnapIndex = Project.Factory.Create<ISpatialIndex<SnapObject>>();
                Project.Factory.PointVisited += Insert;
            }
        }

        protected void OnRenderCompleted(RenderCompletedEventArgs e)
        {
            Project.Factory.PointVisited -= Insert;

            if (Enabled)
            {
                return;
            }

            SnapIndex = null;
        }

        protected void OnDesignerMouseMove(object sender, MouseEventArgs e)
        {
            if (e.Location.IsEmpty || Project.Designer.ActiveComponent == Component)
            {
                return;
            }

            if (Enabled)
            {
                ActiveObjects.Clear();
                Component = Project.Designer.ActiveComponent;

                Project.Designer.Paint += OnDesignerPaint;
                Project.Designer.ActiveComponent.Validating += OnActiveComponentValidating;
                Project.Designer.ActiveComponent.EditCompleted += OnActiveComponentEditCompleted;
            }
        }

        protected void OnDesignerPaint(object sender, PaintEventArgs e)
        {
            if (Enabled)
            {
                var designer = sender as IApplicationComponentDesigner;

                if (SnapLocation.HasValue())
                {
                    Bitmap img;

                    var location = designer.Transform.WorldToClient(SnapLocation);

                    if (Current.HasValue())
                    {
                        img = location.Distance(designer.Mouse.Location) > SnapDistance ? ApplicationAppereance.InactiveSnapImage : ApplicationAppereance.ActiveSnapImage;
                    }
                    else
                    {
                        img = ApplicationAppereance.ClosestSnapImage;
                    }

                    e.Graphics.DrawImageUnscaled(img, (int)(Math.Ceiling(location.X) - img.Width / 2), (int)(Math.Ceiling(location.Y) - img.Height / 2));
                }

                using (var path = new GraphicsPath(FillMode.Winding))
                {
                    if (ClosestSegment.HasValue())
                    {
                        e.Graphics.DrawLine(ApplicationAppereance.Pens.SnapHotTrack, designer.Transform.WorldToClient(ClosestSegment.P0), designer.Transform.WorldToClient(ClosestSegment.P1));
                    }

                    foreach (SnapObject o in ActiveObjects)
                    {
                        path.Reset();

                        if (o.IsCenter)
                        {
                            PointF center = designer.Transform.WorldToClient(o.Value);
                            path.AddEllipse(center.X - CenterPointRadius, center.Y - CenterPointRadius, CenterPointDiameter, CenterPointDiameter);
                            e.Graphics.TryDrawPath(ApplicationAppereance.Pens.HotTrackCenterPointShadow, path);
                            e.Graphics.TryDrawPath(ApplicationAppereance.Pens.HotTrackCenterPoint, path);
                        }
                        else if (o.IsMidPoint)
                        {
                            o.Value.AppendToPath(e.Graphics, path, designer.Transform.WorldToClient, MidPointRadius, false);
                            e.Graphics.TryFillPath(ApplicationAppereance.Brushes.HotTrackMidPoint, path);
                            e.Graphics.TryDrawPath(ApplicationAppereance.Pens.Border, path);
                        }
                        else
                        {
                            o.Value.AppendToPath(e.Graphics, path, designer.Transform.WorldToClient, PointRadius, false);
                            e.Graphics.TryFillPath(ApplicationAppereance.Brushes.HotTrackPoint, path);
                            e.Graphics.TryDrawPath(ApplicationAppereance.Pens.Border, path);
                        }
                    }
                }
            }
        }

        protected void OnActiveComponentValidating(ApplicationComponentEventArgs e)
        {
            var c = e.Component.Value as ICoordinate;

            if (c.HasValue())
            {
                var bounds = e.Designer.GetCursorBounds(SnapQueryBoundsRadius);

                if (SnapIndex == null)
                {
                    Project.Render();
                }

                if (SnapIndex.HasValue())
                {
                    SnapLocation = null;
                    Current = SnapIndex.Query(bounds).Cast<SnapObject>().OrderBy(item => item.Value.Distance(c)).FirstOrDefault();

                    if (Current.HasValue())
                    {
                        SnapLocation = Current.Value;

                        if (e.Designer.Transform.WorldToClient(Current.Value).Distance(e.Designer.Mouse.Location) <= SnapDistance)
                        {
                            PushPoint(Current);
                            Current.Value.CopyTo(c);
                        }
                        else
                        {
                            OnActiveComponentSegmentsValidating(e);
                        }
                    }
                    else
                    {
                        OnActiveComponentSegmentsValidating(e);
                    }
                }
            }
        }

        protected void PushPoint(SnapObject obj)
        {
            if (!ActiveObjects.Contains(obj))
            {
                ActiveObjects.Add(obj);

                while (ActiveObjects.Count > 2)
                {
                    if (!ActiveObjects.Remove(ActiveObjects.First()))
                    {
                        ActiveObjects.Clear();
                    }
                }
            }
        }

        protected void OnActiveComponentSegmentsValidating(ApplicationComponentEventArgs e)
        {
            if (ActiveObjects.Count > 0 || AlignmentGuides.Count > 0)
            {
                var point = e.Component.Value as ICoordinate;

                if (point.HasValue())
                {
                    if (e.Designer.Transform.ClientToWorld(e.Designer.Mouse.X, e.Designer.Mouse.Y, out double x, out double y))
                    {
                        ClosestSegment = GetSegments(x, y).FirstOrDefault();

                        if (ClosestSegment.HasValue())
                        {
                            ValidateClosestCoordinate(e, ClosestSegment, point, x, y);
                        }
                    }
                }
            }
        }

        protected void ValidateClosestCoordinate(ApplicationComponentEventArgs e, ILineSegment segment, ICoordinate item, double x, double y)
        {
            Location.X = x;
            Location.Y = y;

            Current = null;
            SnapLocation = null;

            if (segment.Project(Location))
            {
                PointF point = e.Designer.Transform.WorldToClient(Location);

                if (point.Distance(e.Designer.Mouse.Location) <= SnapDistance)
                {
                    CurrentSegment = segment;
                    Location.CopyTo(item);
                    SnapLocation = Location;
                }
            }
        }

        protected IEnumerable<ILineSegment> GetSegments(double x, double y)
        {
            var o = default(SnapObject);
            var d = Project.Designer.Transform.PixelSize * 16;
            var e = Project.Designer.Transform.DiagonalSize;

            foreach (SnapObject o2 in ActiveObjects.ToArray())
            {
                if (o.HasValue())
                {
                    CurrentSegment.P0.X = o.Value.X;
                    CurrentSegment.P0.Y = o.Value.Y;
                    CurrentSegment.P1.X = o2.Value.X;
                    CurrentSegment.P1.Y = o2.Value.Y;
                    CurrentSegment.Extend(e);

                    if (CurrentSegment.Distance(x, y) <= d)
                    {
                        yield return CurrentSegment;
                    }
                }

                o = o2;
            }

            if (GuideOrigin.HasValue() && AlignmentGuides.Count > 0)
            {
                foreach (ICoordinate o2 in AlignmentGuides.ToArray())
                {
                    CurrentSegment.P0.X = GuideOrigin.X;
                    CurrentSegment.P0.Y = GuideOrigin.Y;
                    CurrentSegment.P1.X = o2.X;
                    CurrentSegment.P1.Y = o2.Y;
                    CurrentSegment.Extend(e);

                    if (CurrentSegment.Distance(x, y) <= d)
                    {
                        yield return CurrentSegment;
                    }
                }
            }
        }

        protected IEnumerable<ICoordinate> GetAlignmentPoints(ICoordinate c, double distance)
        {
            if (ApplicationConfiguration.Current.AlignmentGuides.Enabled)
            {
                int angle = ApplicationConfiguration.Current.AlignmentGuides.Angle;

                for (double n = 0; n < 180; n += angle)
                {
                    double radian = -n * AppConstants.Deg2Rad;

                    yield return Project.Factory.Create<ICoordinate>(c.X + distance * Math.Cos(radian), c.Y + distance * Math.Sin(radian));
                }
            }
        }

        protected void OnActiveComponentChanged(ApplicationComponentEventArgs e)
        {
            GuideOrigin = default;
            AlignmentGuides.Clear();

            if (e.Component.HasValue() && e.Component.Parent.HasValue())
            {
                var c = e.Component.Value as ICoordinate;
                var g = e.Component.Parent.Value as IGeometry;

                if (c.HasValue() && g.HasValue())
                {
                    var segment = g.Coordinates.GetSegments(c).FirstOrDefault();

                    if (segment.HasValue())
                    {
                        GuideOrigin = segment.P0 == e.Component.Value ? segment.P1 : segment.P0;
                        OnAlignmentGuidesSettingsChanged(this, default);
                    }
                }
            }
        }

        protected void OnActiveComponentEditCompleted(ApplicationComponentEditCompletedEventArgs e)
        {
            ClosestSegment = default;
            Component = default;
            Current = default;

            e.Component.Designer.Paint -= OnDesignerPaint;
            e.Component.Validating -= OnActiveComponentValidating;
            e.Component.EditCompleted -= OnActiveComponentEditCompleted;
        }

        public void OnSnapSettingsChanged(object sender, PropertyChangedEventArgs e)
        {
            ActiveObjects.Clear();
            SnapIndex = null;
        }

        public void OnAlignmentGuidesSettingsChanged(object sender, PropertyChangedEventArgs e)
        {
            AlignmentGuides.Clear();

            if (ApplicationConfiguration.Current.AlignmentGuides.Enabled)
            {
                if (GuideOrigin.HasValue() && GuideOrigin.IsEmpty() == false)
                {
                    if (Project.Designer.ActiveComponent.HasValue() && Project.Designer.ActiveComponent.AllowAlignments)
                    {
                        foreach (ICoordinate c in GetAlignmentPoints(GuideOrigin, Project.Designer.Transform.DiagonalSize))
                        {
                            AlignmentGuides.Add(c);
                        }
                    }
                }
            }
        }

        public int CompareTo(object other)
        {
            return CompareTo(other as IApplicationComponentValidator);
        }

        public int CompareTo(IApplicationComponentValidator other)
        {
            return Priority.CompareTo(other.HasValue() ? other.Priority : int.MaxValue);
        }

        public void Dispose()
        {
            ActiveObjects.Clear();
            ActiveObjects = null;

            Project.ActiveComponentChanged -= OnActiveComponentChanged;
            Project.Designer.MouseMove -= OnDesignerMouseMove;
            Project.Workspace.BeginRender -= OnBeginRender;
            Project.Workspace.RenderCompleted -= OnRenderCompleted;

            Project.Application.Settings.Snap.PropertyChanged -= OnSnapSettingsChanged;
            Project.Application.Settings.AlignmentGuides.PropertyChanged -= OnAlignmentGuidesSettingsChanged;

            GC.SuppressFinalize(this);
        }
    }
}