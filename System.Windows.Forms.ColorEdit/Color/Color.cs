//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright © GISExpress 2015-2022. All Rights Reserved.
//  
//  GISExpress .NET API and Component Library
//  
//  The entire contents of this file is protected by local and International Copyright Laws.
//  Unauthorized reproduction, reverse-engineering, and distribution of all or any portion of
//  the code contained in this file is strictly prohibited and may result in severe civil and 
//  criminal penalties and will be prosecuted to the maximum extent possible under the law.
//  
//  RESTRICTIONS
//  
//  THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES ARE CONFIDENTIAL AND PROPRIETARY TRADE SECRETS OF GISExpress
//  THE REGISTERED DEVELOPER IS LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET COMPONENTS AS PART OF AN EXECUTABLE PROGRAM ONLY.
//  
//  THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE
//  COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT
//  AND PERMISSION FROM GISExpress
//  
//  CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON ADDITIONAL RESTRICTIONS.
//  
//  Warning: This content was generated by GISExpress tools.
//  Changes to this content may cause incorrect behavior and will be lost if the content is regenerated.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Globalization;

namespace System.Windows.Forms
{
    internal static class ColorExtensions
    {
        public static HSB ToHsb(this Color c)
        {
            var value = new HSB();

            int max = Math.Max(Math.Max(c.R, c.G), c.B);
            int min = Math.Min(Math.Min(c.R, c.G), c.B);
            double delta = max - min;

            value.Brightness = max / 255.0;
            value.Saturation = max == 0.0 ? 0.0 : delta / max;

            double q = delta == 0.0 ? 0.0 : 60.0 / delta;

            if (c.R == max)
            {
                value.Hue = c.G < c.B ? (360 + q * (c.G - c.B)) / 360.0 : q * (c.G - c.B) / 360.0;
            }
            else if (c.G == max)
            {
                value.Hue = (120 + q * (c.B - c.R)) / 360.0;
            }
            else if (c.B == max)
            {
                value.Hue = (240 + q * (c.R - c.G)) / 360.0;
            }
            else
            {
                value.Hue = 0.0;
            }

            return value;
        }

        /// <summary> 
        /// Converts a colour from HSL to RGB 
        /// </summary> 
        /// <remarks>Adapted from the algoritm in Foley and Van-Dam</remarks> 
        /// <param name="value">The HSL value</param> 
        /// <returns>A Color structure containing the equivalent RGB values</returns> 
        public static Color ToRgb(this HSB value)
        {
            int mid;
            int max = (value.Brightness * 255).Round();
            int min = ((1.0 - value.Saturation) * (value.Brightness / 1.0) * 255).Round();

            double q = (double)(max - min) / 255;

            if (value.Hue >= 0 && value.Hue <= (double)1 / 6)
            {
                mid = (((value.Hue - 0) * q) * 1530 + min).Round();
                return Color.FromArgb(max, mid, min);
            }

            if (value.Hue <= (double)1 / 3)
            {
                mid = (-((value.Hue - (double)1 / 6) * q) * 1530 + max).Round();
                return Color.FromArgb(mid, max, min);
            }

            if (value.Hue <= 0.5)
            {
                mid = (((value.Hue - (double)1 / 3) * q) * 1530 + min).Round();
                return Color.FromArgb(min, max, mid);
            }

            if (value.Hue <= (double)2 / 3)
            {
                mid = (-((value.Hue - 0.5) * q) * 1530 + max).Round();
                return Color.FromArgb(min, mid, max);
            }

            if (value.Hue <= (double)5 / 6)
            {
                mid = (((value.Hue - (double)2 / 3) * q) * 1530 + min).Round();
                return Color.FromArgb(mid, min, max);
            }

            if (value.Hue <= 1.0)
            {
                mid = (-((value.Hue - (double)5 / 6) * q) * 1530 + max).Round();
                return Color.FromArgb(max, min, mid);
            }

            return Color.FromArgb(0, 0, 0);
        }

        public static bool TryParse(string hex, out Color result)
        {
            int rgb;

            if (int.TryParse(hex.TrimStart('#'), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out rgb))
            {
                result = ColorTranslator.FromHtml(string.Concat('#', hex.TrimStart('#')));
                return true;
            }

            result = Color.Empty;
            return false;
        }

        public static string ToHex(this Color c)
        {
            return string.Format("{0:X2}{1:X2}{2:X2}", c.R, c.G, c.B);
        }

        public static int Round(this double value)
        {
            var r = (int)value;
            var t = (int)(value * 100);

            if ((t % 100) >= 50)
            {
                r += 1;
            }

            return r;
        }
    }
}